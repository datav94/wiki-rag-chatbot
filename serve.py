from ray import serve
from fastapi import FastAPI, HTTPException
from http import HTTPStatus
from app.requests import Query
from db.core import VectorDB
from app.prompts import nlp_to_sql_prompt
import configs.cfg as cfg
import sqlparse
import logging
import urllib
app = FastAPI()

logger = logging.getLogger("ude-nli." + __name__)


@serve.deployment(ray_actor_options={"num_gpus":cfg.NUM_GPUS})
@serve.ingress(app)
class NLITranslator:
    def __init__(self):
        """
        The function initializes a tokenizer, a model, and a vector database.
        """
        from ctransformers import AutoModelForCausalLM

        
        logger.error("Starting to retrieve the model")
        urllib.request.urlretrieve(cfg.MODEL_URL, "nsql_ggml-model-q8_0.gguf")
        logger.error("Init the model")

        self.model = AutoModelForCausalLM.from_pretrained(".", model_file=cfg.MODEL_NAME, model_type="llama", gpu_layers=50)
        logger.error("init the DB")
        self.vector_db = VectorDB(cfg.VECTOR_DB_URL)
        logger.error("Init finished")

    @app.post("/translate")
    def translate(self, query: Query) -> str:
        """
        The `translate` function takes a query string as input, searches for a schema using a vector
        database, generates a SQL prompt based on the query and schema, generates SQL code using a
        language model, and returns the formatted SQL code.
        
        :param query: The `query` parameter is a string that represents the query you want to translate.
        It is the input to the translation process
        :type query: str
        :return: The function `translate` returns a string that represents the SQL query generated by
        the model based on the input query. The returned SQL query is formatted using the `sqlparse`
        library to ensure proper indentation.
        """
    
        schema = self.vector_db.search(query.query, cfg.VECTOR_DB_COLLECTION_NAME, cfg.VECTOR_DB_LIMIT)
            
        prompt = nlp_to_sql_prompt(query.query, schema=schema)

        model_output = self.model(prompt)
        return sqlparse.format("SELECT" + model_output.split("SELECT")[-1], reindent=True)

    @app.post("/update")
    def update_db(self):
        """
        The function `update_db` updates a vector database with a given schema and collection name.
        
        :param schema_path: The `schema_path` parameter is a string that represents the path to the
        schema file. This file contains the definition of the database schema, which includes the
        structure and organization of the data in the database
        :type schema_path: str
        :param collection_name: The `collection_name` parameter is a string that represents the name of
        the collection in the database where the schema will be updated
        :type collection_name: str
        """
    
        self.vector_db.update(cfg.SCHEMA_PATH, cfg.VECTOR_DB_COLLECTION_NAME)
        
        
llm_app = NLITranslator.bind()